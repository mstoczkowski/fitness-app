# ADR-0001: Monorepo Tooling â€” pnpm + Turborepo

## Status
Accepted

## Date
2026-01-23

## Context
The project is a greenfield SaaS application in the fitness domain with the following characteristics:

Monorepo containing:
- Web application (Next.js)
- Admin panel (Next.js)
- Mobile application (Expo / React Native)
- Backend API (Python / FastAPI)
- Shared packages (UI, API client, configuration)

Solo / early-stage development with potential to scale into a team later

Heavy use of AI-assisted development (code generation, refactoring, test generation)

Strong focus on fast iteration, short feedback loops, and developer experience

Need for reproducible local and CI builds with caching

A monorepo orchestration and package management strategy is required to:
- Manage multiple applications and shared packages
- Enforce dependency correctness
- Optimize build, test, and lint execution times
- Remain flexible and low-overhead in early stages

## Decision
We decided to use:
- pnpm as the package manager
- Turborepo as the monorepo task runner and build orchestrator

## Rationale
### Why pnpm
- Uses a content-addressable store, significantly reducing disk usage and install time in monorepos
- Strict dependency resolution prevents accidental reliance on undeclared dependencies
- Native workspace support with predictable hoisting behavior
- Excellent compatibility with Next.js, Expo, and modern tooling
- Strong guardrails when working with AI-generated code, reducing hidden dependency bugs

### Why Turborepo
- Lightweight and unopinionated task runner focused on caching and parallelization
- Minimal configuration (turbo.json) with a simple mental model
- Fast local and CI builds through deterministic task caching
- Works seamlessly with heterogeneous stacks (JavaScript/TypeScript + Python)
- Does not impose architectural constraints or project structure
- Very AI-friendly: low DSL complexity reduces the risk of broken configuration generated by AI tools
- First-class support for Next.js and good ecosystem support for Expo/React Native

## Alternatives Considered
### Nx
Pros:
- Powerful dependency graph visualization
- Strong governance features (module boundaries, tagging, ownership)
- Excellent for large teams and enterprise-scale monorepos

Cons:
- Higher setup and configuration complexity
- Strongly JS/TS-centric; Python backend support is less natural
- Introduces additional abstractions (executors, generators, project.json)
- Less friendly for AI-assisted development due to DSL complexity
- Overkill for a solo or early-stage project

### Yarn Workspaces (Classic / Berry)
Pros:
- Mature ecosystem
- Widely known

Cons:
- Less strict dependency enforcement compared to pnpm
- Weaker monorepo task orchestration compared to Turborepo/Nx
- More footguns in AI-assisted workflows

### Plain npm + custom scripts
Pros:
- Zero learning curve

Cons:
- No task graph awareness
- No caching
- Poor scalability as the repository grows

## Consequences
### Positive
- Fast and deterministic builds and tests
- Clean dependency graph across applications and shared packages
- Reduced cognitive load during development
- Excellent fit for AI-assisted workflows
- Easy onboarding and minimal configuration overhead
- Architecture remains flexible and framework-agnostic

### Negative
- Lacks built-in governance features (e.g. enforced module boundaries)
- Requires discipline and conventions as the codebase grows
- Potential need to introduce additional tooling if the team scales significantly

## Future Considerations
If the project scales to a larger team (10+ developers) with stricter architectural governance needs, migration to Nx is feasible.
The current repository structure and task definitions are intentionally designed to keep this option open.
Additional tooling (lint rules, code ownership, ADRs) can mitigate governance gaps in the interim.
